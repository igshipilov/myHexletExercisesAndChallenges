// Задача
/*
https://ru.hexlet.io/challenges/js_functions_nrzi_exercise

NRZI код (Non Return to Zero Invertive) — один из способов линейного кодирования.
Обладает двумя уровнями сигнала и используется для передачи битовых последовательностей,
содержащих только 0 и 1. NRZI применяется, например, в оптических кабелях,
где устойчиво распознаются только два состояния сигнала — свет и темнота.

https://ru.wikipedia.org/wiki/NRZI

Принцип кодирования

При передаче логического нуля на вход кодирующего устройства передается потенциал,
установленный на предыдущем такте (то есть состояние потенциала не меняется),
а при передаче логической единицы потенциал инвертируется на противоположный.

solution.js
Реализуйте и экспортируйте по умолчанию функцию, которая принимает строку в виде графического представления линейного сигнала и возвращает строку с бинарным кодом. Внимательно изучите примеры.

Примеры:
const signal1 = '_|¯|____|¯|__|¯¯¯';
nrzi(signal1); // '011000110100'

const signal2 = '|¯|___|¯¯¯¯¯|___|¯|_|¯';
nrzi(signal2); // '110010000100111'

const signal3 = '¯|___|¯¯¯¯¯|___|¯|_|¯';
nrzi(signal3); // '010010000100111'

const signal4 = '';
nrzi(signal4); // ''

const signal5 = '|';
nrzi(signal5); // ''

Подсказки

Символ | в строке указывает на переключение сигнала и означает,
что уровень сигнала в следующем такте будет изменён на противоположный по сравнению с предыдущим.

*/

/*

# Алгоритм

Используем метод `.reduce()`.

Для него пишем функцию-callback(arr):

if (arr[i] === '_' || '¯' && arr[i + 1] !== '|') {
  return '0'
}
if (arr[i] === '|') {
  return '1'
}

Какой есть аналог  `arr[i]` и `arr[i + 1]` для метода `.reduce()`?
Ведь этот метод итерирует массив по одному элементу за раз.
Ответ: добавь третий аргумент `currentIndex` и на каждой итерации проверяй `arr[currentIndex + 1]`

Только берём `.map(el, index)` вместо `.reduce()`
UPD. А, нет, не работает. Надо где-то засторить массив, потому что не работает el[index + 1]

*/

// Подсказки себе
//  '|¯|' === '11'
// количество '|' равно количеству '1'
// количество '_' или '¯' равно количеству '0' плюс один
// ВСЁ это эозначет, что если предыдущий элемент '|', то пропускается следующий за ним '_' или '¯'

// ============= MY =====================

// Используем для проверки: если итерируемый элемент '|',
// тогда применяем эту функцию к прошлому результату вывода
// и возвращаем его противоположное значение: '0' или '1'
// const isOne = (symbol) => !!Number(symbol);

// console.log(isOne(0))
// console.log(isOne('42') ? '1' : '0')
// console.log(isOne('0') ? '1' : '0')

// // ------ V01 ---------------
// const nrzi = (str) => {
//   if (str.length === 0 || (str.length === 1 && str[0] === '|')) {
//     return '';
//   }
//   const arr = str.split('');

//   const result = arr.map((el, index) => {
//     if (el === '|') {
//       return '1';
//     }
//     if (el === '_' || '¯') {
//       if (arr[index - 1] !== '|') {
//         return '0';
//       }
//     }
//   });

//   return result.join('');
// };
// --------------------------------

// ------ V02 ---------------
// const nrzi = (str) => {
//   if (str.length < 2) {
//     return '';
//   }
//   const isVerticalLine = (symbol) => symbol === '|';
//   const arr = str.split('');

//   // Если текущий элемент – палка, то вернуть 1,
//   // иначе проверить если пред. элемент НЕ палка, то вернуть 0
//   const getZeroOrOne = (el, index) => {
//     const prev = arr[index - 1];
//     const numFromPrevSymbol = !isVerticalLine(prev) ? '0' : '';

//     return isVerticalLine(el) ? '1' : numFromPrevSymbol;
//   };
//   const result = arr.map(getZeroOrOne);

//   return result.join('');
// };
// --------------------------------

// ======================================

// ============= TEACHER =====================
const nrzi = (str) => str
  .split('')
  .map((element, index, arr) => {
    if (element === '|') return '';
    return arr[index - 1] !== '|' ? 0 : 1;
  })
  .join('');

// ===========================================

const signal01 = '_ | ¯ | _ _ _ _ | ¯ | _ _ | ¯ ¯ ¯';
// console.log(nrzi(signal0)); //  '0 1   1   0 0 0 1   1   0 1 0 0'

const signal02 = '| ¯ | _ _ _ | ¯ ¯ ¯ ¯ ¯ | _ _ _ | ¯ | _ | ¯';
// console.log(nrzi(signal2)); // ' 1   1   0 0 1   0 0 0 0 1   0 0 1   1   1'

const signal1 = '_|¯|____|¯|__|¯¯¯';
console.log(nrzi(signal1)); // '011000110100'
console.log(nrzi(signal1) === '011000110100');

console.log();

const signal2 = '|¯|___|¯¯¯¯¯|___|¯|_|¯';
console.log(nrzi(signal2)); // '110010000100111'
// '010010000100111'
console.log(nrzi(signal2) === '110010000100111');

console.log();

const signal3 = '¯|___|¯¯¯¯¯|___|¯|_|¯';
console.log(nrzi(signal3)); // '010010000100111'
console.log(nrzi(signal3) === '010010000100111');

const signal4 = '';
console.log(nrzi(signal4)); // ''

const signal5 = '|';
console.log(nrzi(signal5)); // ''
