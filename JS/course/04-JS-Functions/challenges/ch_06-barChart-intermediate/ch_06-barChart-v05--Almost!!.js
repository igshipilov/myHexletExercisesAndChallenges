import _ from 'lodash';

// Задача
/*
https://ru.hexlet.io/challenges/js_functions_bar_chart_exercise

Реализуйте и экспортируйте по умолчанию функцию, которая выводит на экран столбчатую диаграмму.
Функция принимает в качестве параметра последовательность чисел, длина которой равна
количеству столбцов диаграммы. Размер диаграммы по вертикали должен определяться входными данными.

Примеры

import barChart from '../solution.js';

barChart([5, 10, -5, -3, 7]);
// =>  *
//     *
//     *
//     *  *
//     *  *
//    **  *
//    **  *
//    **  *
//    **  *
//    **  *
//      ##
//      ##
//      ##
//      #
//      #

barChart([5, -2, 10, 6, 1, 2, 6, 4, 8, 1, -1, 7, 3, -5, 5]);
// =>   *
//      *
//      *     *
//      *     *  *
//      **  * *  *
//    * **  * *  *  *
//    * **  ***  *  *
//    * **  ***  ** *
//    * ** ****  ** *
//    * ******** ** *
//     #        #  #
//     #           #
//                 #
//                 #
//                 #

Подсказки:

Для решения задачи вы можете использовать функции из библиотеки lodash
https://lodash.com/docs/4.17.15

*/

/*

# Алгоритм

Вообще, надо получить массив, состоящий из подмассивов,
где каждый элемент (подмассив) – это шаг массива-аргумента функции `barChart()`.

В каждом подмассиве будут только числа: -1, 0, 1.
  - все нули заменяются пробелом
  - все единицы заменяются звёздочкой
  - все минус единицы заменяются решёткой.

Значение элемента (число) – это количество строчек,
в которых на данном индексе будет записан символ '*' или '#' или ' ' (пробел).

--------------

Проходимся по массиву.

Возвращаем массив с подмассивами, где каждый подмассив равен длине основного массива.
Итерируем каждый элемент каждого подмассива:
  - если элемент >0, то делаем ему -1, пока `Mat.max()` >0
  - если элемент <0, то делаем ему +1, пока `Mat.min()` <0

Методом `.map()` ещё раз проходимся по каждому элементу каждого подмассива,
применяем к каждому элементу Math.sign() и сразу же:
  - если элемент `1`, то заменяем его на `*`
  - если элемент `1`, то заменяем его на `*`
  - если элемент `0`, то заменяем его на `' '` (пробел)

Если `el` меньше `max`, то `return 0`,
иначе `return el - 1`

## Идея: поворот матрицы

Создаём матрицу: массив подмассивов.

Каждый подмассив – это единицы, их количество мы определяем
по значению текущего итерируемого элемента массива.

Как обрабатываем отрицательные значения?
Минус должен влиять на сторону, с которой мы добавим нули.

  Если итерируемый элемент >0, то нули дописываются справа -- `.push()`?
  Если итерируемый элемент <0, то нули дописываются слева -- `.unshift()`?

  Заполнять лучше методом `.fill(value, start, end)

Поворачиваем матрицу _.reverse(_.zip())

*/

// ============= MY =====================

// Мы строим график сразу по каждому итерируемому числу
// При этом каждое число дозаполняется нулями до суммы `max` и `min`,
// но `max` считается, если в массиве есть хотя бы одно положительное число,
// а `min` считается, если в массиве есть хотя бы одно отрицательное число.
//

// Написать функцию, которая проверяет, есть ли в массиве хотя бы одно положительное число.
// Guard Expression отсеит пустые массивы, поэтому достаточно проверить на 'positiveness',
// т.к. иначе в массиве только отрицательные числа.

// Надо понять, суммировать ли `min + max`
// или вовзращать только `min`,
// или вовзращать только `max`.
// Для этого

// Дозаполнять строку нулями надо в обе стороны:
// `.padStart(min, bar)` и `.padEnd(max, bar)`

// -----------------------------------------------------

// ХРЕНАЧИТ ВСЁ В ОДНУ СТОРОНУ --> СТОЛБИКИ ПОЛЗУТ
const getLine = (number, size) => {
  const bar = number > 0 ? '*' : '#';
  const space = ' ';

  if (number > 0) {
    return bar.repeat(number).padEnd(size, '0').split('');
  } if (number < 0) {
    return bar.repeat(Math.abs(number)).padStart(size, '0').split('');
  }
  return space;
};

// console.log(getLine('3', 6));

const hasPositiveOnly = (numbers) => numbers.filter((number) => number < 0).length === 0;
const hasNegativeOnly = (numbers) => numbers.filter((number) => number > 0).length === 0;

const getSize = (numbers) => {
  const max = Math.max(...numbers);
  const min = Math.abs(Math.min(...numbers));
  const sum = max + min;

  if (hasPositiveOnly(numbers)) {
    return max;
  } if (hasNegativeOnly(numbers)) {
    return min;
  }
  return sum;
};

const arr = [3, -2, 1, -1];
// console.log(getSize(arr));

const getMatrix = (numbers) => numbers.map((number) => getLine(number, getSize(numbers)));
console.log(getMatrix(arr));

const rotateMatrix = (matrix) => _.zip(...matrix);
// const rotateMatrix = (matrix) => matrix.length > 0 ? _.zip(...matrix) : [];
console.log(rotateMatrix(getMatrix(arr)));

// [1, 3, 2]
// =>
// [0, 1, 0]
// [0, 1, 1]
// [1, 1, 1]

// const arr1 = [5, 10, -5, -3, 7];

// В тестах `arr2` снизу вылазят две лишние строчки, наполненные пробелами.
// const arr2 = [6, 8, 8, 8, 8, 8, 7, 6, 2, 6, 6, 8, 4, 6, 5, 2, 6, 7, 3, 7];
// barChart(arr2);
// =>  *
//     *
//     *
//     *  *
//     *  *
//    **  *
//    **  *
//    **  *
//    **  *
//    **  *
//      ##
//      ##
//      ##
//      #
//      #

// barChart([5, -2, 10, 6, 1, 2, 6, 4, 8, 1, -1, 7, 3, -5, 5]);
// =>   *
//      *
//      *     *
//      *     *  *
//      **  * *  *
//    * **  * *  *  *
//    * **  ***  *  *
//    * **  ***  ** *
//    * ** ****  ** *
//    * ******** ** *
//     #        #  #
//     #           #
//                 #
//                 #
//                 #
