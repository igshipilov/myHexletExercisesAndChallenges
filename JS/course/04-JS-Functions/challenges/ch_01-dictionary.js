import _ from 'lodash';
// Задача

/*
https://ru.hexlet.io/challenges/js_functions_dictionaries_merge_exercise

Реализуйте и экспортируйте по умолчанию функцию, которая объединяет несколько словарей (объектов) в один общий словарь.
Функция принимает любое количество аргументов и возвращает результат в виде объекта,
в котором каждый ключ содержит список уникальных значений в виде массива.
Элементы в списке располагаются в том порядке, в котором они появляются во входящих словарях.

Примеры работы:

merge({}, {}, {});
// {}

merge({ a: 1, b: 2 }, { a: 3 });
// { a: [1, 3], b: [2] }

merge(
    { a: 1, b: 2, c: 3 },
    {},
    { a: 3, b: 2, d: 5 },
    { a: 6 },
    { b: 4, c: 3, d: 2 },
    { e: 9 },
  );
// { a: [1, 3, 6], b: [2, 4], c: [3], d: [5, 2], e: [9] }

*/

/*

# Алгоритм
Функция принимает неогр. число аргументов: `merge(...obj)`

Итеративно каждый элемент (объект) превращаем в массив с помощь `Object.entries(obj)`

С помощью `.reduce(callback, {})` возвращаем объект, наполненный `ключами: [с, массивами, как, значениями]`
  Наполняем объект так:

# Шпаргалка
const test = (...obj) => { return obj }; // [ { obj1 }, { obj2 },... { objN } ]

const obj1 = { a: 1, b: 2 };
const obj2 = { a: 3 };

const arr = Object.entries(obj1);
const [key1, value1] = arr[0];
const [key2, value2] = arr[1];

const arr2 = Object.entries(obj2);
const [key3, value3] = arr2[0];

const updObj = {};

updObj[key1] = [];
updObj[key1].push(value1);

updObj[key2] = [];
updObj[key2].push(value2);

updObj[key3].push(value3);

console.log(updObj);

*/

/*
Мой вопрос

Не понимаю, почему получаю разные результаты работы двух, как мне кажется, идентичных функций?

Испытание dictionary.js: https://codepen.io/Shin_im/pen/abPmBGJ?editors=0012
Упражнение groupBy: https://codepen.io/Shin_im/pen/KKbgNRP

В алгоритмах решения обеих задач отличаются первый и третий пункты, но вопрос у меня только по первому пункту (остальные два описываю только для понимания контекста этих задач):

1.Проверяем, есть ли в аккумуляторе ключ с указанным именем:
-- в Испытании имя = имя
-- в Упражнении имя = значение (берём значение ключа из оригинального объекта и записываем его в аккумулятор в качестве имени)

2. Если в аккумуляторе ключа с таким именем нет, то создаём ключ:
-- в Испытании название ключа = его имени
-- в Упражнении название ключа = его значению
В обоих случаях его значением становится пустой массив.

3. Затем пушим  в аккумулятор нужные для решения каждой задачи данные:
-- в Испытании пушим значение текущего итерируемого ключа
-- в Упражнении пушим текущий итерируемый объект.

Вопрос: почему в Испытании прежде чем запушить приходится проводить доп. проверку в виде: `if (!acc[key].includes(value)) {`? Если не сделать этой проверки, то повторяющиеся значения пушатся вновь.

Блин. Я понял: повторяющиеся значения пушатся в обоих случаях.

*/

// ============= MY =====================

// --------- for of -------------------
// const merge = (...obj) => {

//   const callback = (acc, currentObj) => {
//     const arr = Object.entries(currentObj); // { a: 1, b: 2 } --> [ [ 'a', 1 ], [ 'b', 2 ] ]
//     // Итерируем каждый элемент полученного `arr`
//     for (const [key, value] of arr) {
//       if (!Object.hasOwn(acc, key)) {
//         acc[key] = [];
//       }
//       if (!acc[key].includes(value)) {
//         acc[key].push(value);
//       }
//     }
//     return acc;
//   };

//   return obj.reduce(callback, {});
// };
// -----------------------------------

// --------- LODASH-TEACHER --------------

const cons = (list, el) => _.union(list, [el]);

const merge = (...dictionaries) => _.mergeWith({}, ...dictionaries, cons);

// -------------------------------

// ======================================

// ----------------- Объяснение решения учителя ----------------------
// `_.mergeWith()` принимает три аргумента:

// • целевой объект (изначально пустой, он будет наполняться): `{}`
// • все итерируемые объекты: `...dictionaries`
// • функцию-кастомайзер: `cons`

// Объекты справа перезаписывают совпадающие значения в объектах слева, в том числе перезаписывают значения целевого.
// Например:
// _.merge( { a: 1, b: 2 }, { a: 3 } );  // => { a: 3, b: 2 }
// _.merge( { a: 1, b: 2 }, { a: 3 }, { b: 4, c: 5 } );  // => { a: 3, b: 4, c: 5 }

// `_.mergeWith()` – это расширенная версия `_.merge()`

// Функция cons принимает два аргумента:
// • пустой массив: `list`
// • текущий элемент: `el`

// Затем она обрабатывает их функцией `_.union(list, [el])`, при этом
// видим, что текущий элемент помещается в подмассив уже в момент записи его в аргумент функции: `[el]`

// Вопрос: как `_.union()` понимает, что `list` – это массив?

console.log(merge({}, {}, {}));
// {}

console.log(merge({ a: 1, b: 2 }, { a: 3 }));
// { a: [1, 3], b: [2] }

console.log(merge(
  { a: 1, b: 2, c: 3 },
  {},
  { a: 3, b: 2, d: 5 },
  { a: 6 },
  { b: 4, c: 3, d: 2 },
  { e: 9 },
));
// { a: [1, 3, 6], b: [2, 4], c: [3], d: [5, 2], e: [9] }
