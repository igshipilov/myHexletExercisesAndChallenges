// @ts-check
/* eslint-disable import/prefer-default-export */

/*

Реализуйте и экспортируйте асинхронную функцию getDirectorySize(),
которая считает размер переданной директории, не включая поддиректории.
Анализ размера файла должен происходить параллельно, для этого воспользуйтесь библиотекой async.

Примеры

import { getDirectorySize } from './info.js';

getDirectorySize('/usr/local/bin', (err, size) => {
  console.log(size);
});

Подсказки
  • fs.readdir() - чтение содержимого директории, возвращает файлы и поддиректории,
  находящиеся в переданной директории, в виде массива, где имена поддиректорий
  и файлов это строки.

  • path.join() - конструирует пути

  • async.map()

  • fs.stat() - информация о файле.
  В получаемом объекте содержится метод isFile() для проверки является ли элемент файлом

  • _.sumBy() - нахождение суммы в массиве

  • колбек должен вызываться и в случае ошибки

*/

/*

ЗАДАЧА КОРОТКО

1. Наша функция получает путь до директории
2. Находит в ней все файлы
3. Возвращает их суммарный размер.

Уточнение:
Если в директории нет файлов, но есть поддиректории, то размер директории равен нулю
даже если в поддиректориях есть файлы.

АЛГОРИТМ

Узнать размер директории, а для этого
узнать размер каждого файла внутри неё.

1. С помощью `fs.readdir` получаем массив, содержащий список строк-имён поддиректорий и файлов.
Фильтруем его, исключюая все поддиректории, сохраняем в константу `list`.

2. Проверяем, является ли текущий элемент файлом:
  - если `stats.isFile() === true`, то возвращаем (?) его размер `size`, как метод класса `fs.Stats`
  (или не "возвращаем", а "передаём в колбек"?)

Работаем в главной фукнции `async.map(list, fs.stat, cb)`
  - будет ли колбек изменяемым или я запекаю его?

`path.join` переданный пользователем аргумент `dirPath`
сцепляет с каждым файлом внутри переданной директории. Результаты будут вроде:
  - /bin/apt-install
  - /bin/pip

И эти результаты он подставляет в `fs.stat`.

*/

import path from 'path';
import fs from 'fs';
import _ from 'lodash';
import async from 'async';

// BEGIN (write your solution here)
export const getDirectorySize = (dirPath, cb) => {
  // Получаю список (массив строк) с именами директорий и файлов,
  // находящихся в указанной директории (dirPath)
  fs.readdir(dirPath, (readDirError, filenames) => {
    if (readDirError) {
      cb(readDirError);
      return;
    }

    // Чтобы async.map смогла применить каждый элемент массива для fs.stat,
    // надо содержимое массива (пути до элементов – директорий и файлов)
    // привести к корректному виду, потому что сейчас путь недостаточный
    const filenamesFullPath = filenames.map((el) => path.join(dirPath, el));

    // с помощью async.map мы по одному элементу подставляем в fs.stat,
    // fs.stat превращает каждый элемент в объект fs.Stats (ищи "Class: fs.Stats" по ссылке: https://nodejs.org/api/fs.html#class-fsstats)
    // и сохраняет в новом массиве под названием stats (второй аргумент колбека функции async.map)
    async.map(filenamesFullPath, fs.stat, (err, stats) => {
      if (err) {
        return;
      }

      // Так как каждый элемент у нас является объектом,
      // а нам надо знать сумму значений только одного его свойства (size),
      // то для этого удобно использовать лодашевскую функцию _.sumBy().
      // Предварительно отфильтровываем директории – по условию задачи они нам не нужны, нужны только файлы.
      const sum = (_.sumBy(stats?.filter((stat) => stat.isFile()), 'size'));

      // В конце работы асинхронных функций всегда передаём результат в колбек
      // (здесь это второй аргумент функции getDirectorySize),
      // чтобы асинхронная функция вернула инфу наружу.

      // А первым аргументом (null) у нас вообще-то должен идти обработчик ошибок,
      // например console.log с сообщением об ошибке, но пока для упрощения обучения
      // мы используем просто null.
      cb(null, sum);
    });
  });
};
// END

// ============= TEACHER =====================
// export const getDirectorySize = (dirPath, cb) => {
//   // читаем содержимое переданной папки dirPath
//   // readdir принимает вторым аргументом колбэк с двумя аргументами
//   // второй аргумент колбэка, fileNames, - это массив имен файлов и папок
//   fs.readdir(dirPath, (error1, fileNames) => {
//     // первым делом обрабатываем ошибку - передаем ошибку в колбэк cb,
//     // опуская 2-й аргумент, хотя допустимо туда явно передавать null,
//     // а из самой функции выходим через return
//     if (error1) {
//       cb(error1);
//       return;
//     }
//     // если ошибки нет - работаем
//     // собираем путь к каждому файлу, синхронная функция
//     const filePaths = fileNames.map((name) => path.join(dirPath, name));
//     // теперь извлекаем информацию о каждом файле/папке
//     // при помощи асинхронной функции fs.stat
//     // она тоже принимает вторым аргументом колбэк с двумя аргументами
//     async.map(filePaths, fs.stat, (error2, stats) => {
//       // точно так же обрабатываем ошибку
//       if (error2) {
//         cb(error2);
//         return;
//       }
//       // если ошибок нет, мы работаем с массивом stats -
//       // результатом применения fs.stat к каждому элементу массива filePaths
//       // в _.sumBy() передаем массив отфильтрованных файлов первым аргументом,
//       // ведь поддиректории мы тут не учитываем,
//       // а вторым - имя свойства, по которому осуществляем сложение,
//       const sum = _.sumBy(stats.filter((stat) => stat.isFile()), 'size');
//       // передаем результат во второй параметр колбэка
//       cb(null, sum);
//     });
//   });
// };
// ===========================================
