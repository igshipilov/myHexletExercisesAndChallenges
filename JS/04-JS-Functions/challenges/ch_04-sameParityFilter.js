// Задача
/*

Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход массив и возвращает новый,
состоящий из элементов, у которых такая же чётность, как и у первого элемента входного массива.

Примеры

sameParity([-1, 0, 1, -3, 10, -2]); // [-1, 1, -3]
sameParity([2, 0, 1, -3, 10, -2]); // [2, 0, 10, -2]
sameParity([]); // []

*/

/*

# Алгоритм

Проверяем первый элемент: isEven --> arr[0] % 2 === 0
  если да, то вернуть новый массив, заполнив его числами из текущего массива, делящимися на два без остатка
  если да, то вернуть новый массив, заполнив его числами из текущего массива, НЕ делящимися на два без остатка

*/

// ============= MY =====================

const isEven = (num) => (num % 2 === 0);

// const sameParity = (numbers) => {
//   if (numbers.length === 0) {
//     return [];
//   }
//   const [firstNumber] = numbers;
//   if (isEven(firstNumber)) {
//     return numbers.filter((num) => isEven(num));
//   } return numbers.filter((num) => !isEven(num));
// };

// ======================================

// ============= TEACHER =====================

const sameParity = (arr) => {
  const firstItemParity = isEven(arr[0]);
  return arr.filter((el) => isEven(el) === firstItemParity);
};

// firstItemParity проверяет, является ли первое число в массиве чётным
// и затем сохраняет в себе ответ `true` или `false`

// isEven(el) проверяет первое число на чётность,
// и тоже сохраняет в себе ответ `true` или `false`

// isEven(el) === firstItemParity
// это условие для работы `.filter`: возвращаем текущий элемент только если оба предиката вернули одинаковое значение
// `true` === `true` или `false` === `false`

// ===========================================

// console.log(sameParity(test));

console.log(sameParity([-1, 0, 1, -3, 10, -2])); // [-1, 1, -3]
console.log(sameParity([2, 0, 1, -3, 10, -2])); // [2, 0, 10, -2]
console.log(sameParity([])); // []
